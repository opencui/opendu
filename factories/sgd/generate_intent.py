#!/usr/bin/env python
# coding: utf-8

import json
import os
import sys
import gin
import random
from collections import defaultdict
from factories import Dataset
import torch
import pandas as pd
from factories.base.core import save, ModelEncoder, GenerateIntentExamples, IntentMeta, check_stop_words, Expression

# pip install -U gin-config faiss-cpu scikit-learn sentence-transformers
# python3 generate_intent.py --input=/home/sean/src/dstc8-schema-guided-dialogue/train/ --output=./res/train

sys.path.insert(0, "./base/")


@gin.configurable
class SgdDataset:
    def __init__(self, input, output,
                 stop_word_path,  # output path to save generated intent model examples'
                 fix_random_seed=True,  # 'use fixed random seed(for debug)'
                 pos_num=-1,  # 'num of positive sample num generated by each intent'
                 neg_num=-1,  # 'num of negative sample num generated by each intent'
                 training_percentage=1.0,  # 'percentage for training'
                 negative_proportions=1.0,  # 'how many negative examples to generate for each positive example'
                 dev_percentage=1.0,  # 'percentage for dev'
                 decode_method='transformer',  # 'embedding method for the sentence'
                 cover_filter=False,  # 'whether we use the cover_relation to filter the sentence'
                 random_generate=True):  # 'generating the utterance by replacing the slot name with slot val
        self.input = input
        self.output = output
        self.stop_word_path = stop_word_path
        self.fix_random_seed = True
        self.pos_num = pos_num
        self.neg_num = neg_num
        self.training_percentage = training_percentage
        self.negative_proportions = negative_proportions
        self.dev_percentage = dev_percentage
        self.decode_method = decode_method
        self.cover_filter = cover_filter
        self.random_generate = random_generate

    def label(self, pmodel="intents"):
        return f"{pmodel}_{self.decode_method}_random_{self.random_generate}_cover_{self.cover_filter}_pos_{self.pos_num}_neg_{self.neg_num}"


# This load the schema.
def load_description_dataset(base_path):
    intent_desc = defaultdict(list)
    with open(base_path + 'schema.json', encoding='utf-8') as f:
        f = json.load(f)

        for service in f:
            # in the "overall"   generate mode,only pick <service>_1  if there are multiple  services for one intent
            if service["service_name"][-1] != '1':
                continue
            service_name = service["service_name"]
            intents = service["intents"]
            for intent in intents:
                intent_name = intent['name']
                if intent_name in intent_desc.keys():
                    print(f"{intent_name} is repeated in {service_name}")
                intent_desc[intent_name] = intent["description"]
    results = pd.DataFrame({"source": intent_desc.keys(), "text": intent_desc.values()})
    results = Dataset.from_pandas(results)
    results = results.map(
        lambda x: {"embeddings": torch.nn.functional.normalize(encoder.convert([x["text"]])).detach().cpu().numpy()[0]}
    )

    results.add_faiss_index(column="embeddings")
    return results


def load_intent_meta(base_path):
    """
    load original sgd data and create expression examples
    :param base_path: input path to original sgd dataset
    :return: expression examples
    """
    intent_templates = defaultdict(IntentMeta)
    files = os.listdir(base_path)
    sentence_set = defaultdict(set)
    for file in files:
        if file[:6] != 'dialog':
            continue
        with open(base_path + file, encoding='utf-8') as f:
            f = json.load(f)
            for dialogue in f:
                turns = dialogue["turns"]
                pre_intents = set()
                for idx, turn in enumerate(turns):
                    if turn['speaker'] != 'USER':
                        continue
                    active_intents = set()
                    for frame in turn['frames']:
                        active_intents.add(frame['state']['active_intent'])

                    if idx - 1 >= 0 and turns[idx - 1]["frames"][0]["actions"][0]["act"] == "OFFER_INTENT":
                        check_intent = set(turns[idx - 1]["frames"][0]["actions"][0]["values"])
                    else:
                        check_intent = set()

                    if not (active_intents - pre_intents or (not pre_intents)):
                        continue

                    frame = turn['frames'][0]
                    if frame['service'][-1] == '1' and (
                            frame['state']['active_intent'] in active_intents - pre_intents) and \
                            frame['state']['active_intent'] != 'NONE' and \
                            frame['state']['active_intent'] not in check_intent:
                        string_list = []
                        utterance_slot = defaultdict(list)
                        for _slot in frame['slots']:
                            utterance_slot[_slot['slot']].append(turn['utterance'][_slot['start']:_slot['exclusive_end']].lower())
                            string_list.append((_slot['start'], _slot['exclusive_end']))

                        if not check_stop_words(utterance_slot, turn['utterance'].lower(), string_list, FLAGS.stop_word_path):
                            continue
                        expression = Expression(turn['utterance'].lower(), frame['state']['active_intent'], utterance_slot, string_list)
                        intent_templates[frame['state']['active_intent']].add_sample(expression)
                        sentence_set[frame['state']['active_intent']].add(expression.utterance)
                    pre_intents = active_intents
    return intent_templates


def generate_slot_index(base_path):
    slot_index = defaultdict(list)
    with open(base_path + 'schema.json', encoding='utf-8') as f:
        f = json.load(f)
        for service in f:
            # in the "overall"   generate mode,only pick <service>_1  if there are multiple  services for one intent
            if service["service_name"][-1]!= '1':
                continue

            for intent in service['intents']:
                slot_index[intent['name']] = []
                for name in intent['required_slots']:
                    for slot in service['slots']:
                        if slot['name'] == name:
                            slot_index[intent['name']].append(name)
                for name in intent['optional_slots'].keys():
                    for slot in service['slots']:
                        if slot['name'] == name:
                            slot_index[intent['name']].append(name)
                slot_index[intent['name']] = list(set(slot_index[intent['name']]))
    return slot_index


if __name__ == '__main__':
    gin.parse_config_file(sys.argv[1])

    FLAGS = SgdDataset()
    save([], FLAGS.output, "test")

    encoder = ModelEncoder()

    descriptions_dataset = load_description_dataset(FLAGS.input)

    templates = load_intent_meta(FLAGS.input)

    for key in templates:
        templates[key].finalize(encoder)

    # now we can create intent examples.
    build_intent_examples = GenerateIntentExamples(encoder)
    examples = build_intent_examples(templates, descriptions_dataset)
    save(examples, FLAGS.output, FLAGS.label())
